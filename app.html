<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>PubNub Mouse Sharing</title>
  <!-- Style: Dark background, canvas covering full page, star animation -->
  <style>
    html, body {
      margin: 0; 
      padding: 0; 
      overflow: hidden; 
      background: radial-gradient(ellipse at center, #111 0%, #000 100%);
      height: 100vh; 
      width: 100vw; 
      user-select: none; 
      cursor: crosshair; 
      font-family: sans-serif;
    }
    #starfield {
      position: fixed;
      top:0; 
      left:0; 
      width:100%;
      height:100%;
      pointer-events: none; 
      z-index: 0;
      background: transparent 
        url('./background.png') repeat center center; 
      animation: twinkle 100s linear infinite;
      opacity: 0.4;
    }
    @keyframes twinkle {
      0% { background-position: 0 0; }
      100% { background-position: 1000px 1000px; }
    }
    #gameCanvas {
      position: fixed; 
      top: 0; 
      left: 0; 
      width: 100vw; 
      height: 100vh; 
      z-index: 1; 
      display: block;
    }
    #pubnub-logo {
        position: fixed;
        bottom: 20px;
        right: 20px;
        width: 200px;
        height: 70px;
        z-index: 100;
        background: url('pubnub-logo.png') no-repeat center center;
        background-size: contain;
    }
    #info {
      position: fixed;
      bottom: 5px;
      left: 5px;
      color: #ccc;
      font-size: 14px;
      z-index: 2;
      background: rgba(0,0,0,0.5);
      padding: 5px 8px;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <div id="pubnub-logo"></div>
  <!-- Background starfield layer -->
  <div id="starfield"></div>
  <!-- The canvas where cursors are drawn -->
  <canvas id="gameCanvas"></canvas>
  <!-- Info box -->
  <div id="info">
    Move your mouse to share its position in real time via PubNub!
  </div>
  <script src='./pubnub.js'></script>
  
  <!-- PubNub SSE from UNPKG (async iterator style) -->
  <script type="module">
    // Basic setup
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    resizeCanvas();

    // Resize canvas on window changes
    window.addEventListener('resize', resizeCanvas);
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }

    // Generate a random userId so each tab is unique
    const userId = 'user-' + Math.floor(Math.random() * 999999999);

    // Create a PubNub instance using demo keys or your own keys
    const pubnub = PubNub({
      subscribeKey: 'demo',
      publishKey: 'demo'
    });

    // Use a shared channel name
    const CHANNEL = 'mouse-channel';

    // Subscribe to the channel (note the array form!)
    const subscription = pubnub.subscribe({ channel: CHANNEL, messages: receiveMessages });

    // Maintain a dictionary of remote cursors (by userId)
    // Each entry: { x, y, targetX, targetY, color }
    const cursors = {};

    // Generate a random color for this user
    const myColor = randomColor();

    // Listen for mouse moves, publish local position
    let lastPublishTime = 0;
    window.addEventListener('mousemove', (e) => {
      const now = Date.now();
      // For demonstration, letâ€™s publish ~ every 50 ms
      if (now - lastPublishTime > 50) {
        pubnub.publish({
          channel: CHANNEL,
          message: {
            userId: userId,
            data: { x: e.clientX, y: e.clientY, color: myColor }
          }
        });
        lastPublishTime = now;
      }
    });

    // Receive messages with an async iterator
    async function receiveMessages(message) {
        console.log('[SUBSCRIPTION EVENT]', message);
        
        if (!message || !message.userId || !message.data) return;
        const incomingUserId = message.userId;
        const data = message.data;
        if (!incomingUserId || !data) return;

        // Ignore our own published messages
        if (incomingUserId === userId) return;

        // If new user, create cursor data; otherwise update
        if (!cursors[incomingUserId]) {
          cursors[incomingUserId] = {
            x: data.x,
            y: data.y,
            targetX: data.x,
            targetY: data.y,
            color: data.color,
          };
        } else {
          cursors[incomingUserId].targetX = data.x;
          cursors[incomingUserId].targetY = data.y;
        }
    }
    receiveMessages();

    // Local cursor data
    let localCursor = {
      x: 0,
      y: 0,
      targetX: 0,
      targetY: 0,
      color: myColor
    };

    // Update our local cursor target on mousemove
    window.addEventListener('mousemove', e => {
      localCursor.targetX = e.clientX;
      localCursor.targetY = e.clientY;
    });

    // Touch support: update local cursor target on touchmove
    window.addEventListener('touchmove', e => {
      e.preventDefault();
      const touch = e.touches[0];
      localCursor.targetX = touch.clientX;
      localCursor.targetY = touch.clientY;
    });

    // Animation loop: smoothly move each cursor toward its target and draw it
    function animate() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Update/draw our own cursor
      smoothMove(localCursor);
      drawCursor(localCursor.x, localCursor.y, localCursor.color, true);

      // Update/draw remote cursors
      for (const [uid, cursor] of Object.entries(cursors)) {
        smoothMove(cursor);
        drawCursor(cursor.x, cursor.y, cursor.color, false);
      }

      requestAnimationFrame(animate);
    }
    animate();

    // Helper: smoothly move a cursor toward its target position
    function smoothMove(cursor) {
      cursor.x += 0.1 * (cursor.targetX - cursor.x);
      cursor.y += 0.1 * (cursor.targetY - cursor.y);
    }

    // Helper: draw a circular cursor
    function drawCursor(x, y, color, isLocal) {
      ctx.save();
      const radius = isLocal ? 20 : 15;
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, 2 * Math.PI);
      ctx.fillStyle = color;
      ctx.shadowColor = color;
      ctx.shadowBlur = 15;
      ctx.fill();
      ctx.restore();
    }

    // Helper: get a random HSL color
    function randomColor() {
      return 'hsl(' + (Math.random()*360).toFixed(0) + ', 70%, 50%)';
    }
  </script>
</body>
</html>
